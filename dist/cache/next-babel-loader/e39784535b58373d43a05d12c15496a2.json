{"ast":null,"code":"var _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _JSON$stringify = require(\"@babel/runtime-corejs2/core-js/json/stringify\");\n\nvar _defineProperty = require(\"@babel/runtime-corejs2/helpers/defineProperty\");\n\nvar _Promise = require(\"@babel/runtime-corejs2/core-js/promise\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/*\n  parse and return email data\n  (browser)\n*/\nconst Hashes = require(\"jshashes\");\n\nconst parse = require(\"./parse\");\n\nconst toSolidity = require(\"./utils/toSolidity\");\n\nconst publicKeyToComponents = require(\"./utils/publicKeyToComponents\");\n\nconst main = email => {\n  return new _Promise(async (resolve, reject) => {\n    // get dkims\n    const dkims = parse(email).dkims.map(dkim => {\n      const algorithm = dkim.algorithm.split(\"-\").pop().toUpperCase();\n      const bodyHashMatched = new Hashes[algorithm]().hex(dkim.processedBody) === dkim.signature.hash.toString(\"hex\");\n\n      if (!bodyHashMatched) {\n        return reject(\"body hash did not verify\");\n      }\n\n      const hash = new Hashes[algorithm]().hex(dkim.processedHeader);\n      return _objectSpread({}, dkim, {\n        hash\n      });\n    }); // get dns records\n\n    const publicKeys = await fetch(\"/api/getPublicKeys\", {\n      method: \"POST\",\n      mode: \"same-origin\",\n      cache: \"no-cache\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      referrer: \"no-referrer\",\n      body: _JSON$stringify(dkims.map(dkim => ({\n        domain: dkim.signature.domain,\n        selector: dkim.signature.selector\n      })))\n    }).then(res => res.json()).then(entries => {\n      return entries.map(entry => {\n        const {\n          publicKey\n        } = entry;\n        const {\n          exponent,\n          modulus\n        } = publicKeyToComponents(publicKey);\n        return _objectSpread({}, entry, {\n          exponent,\n          modulus\n        });\n      });\n    }).catch(reject);\n    return resolve(dkims.map((dkim, i) => {\n      const solidity = toSolidity({\n        algorithm: dkim.algorithm,\n        hash: dkim.hash,\n        signature: dkim.signature.signature,\n        exponent: publicKeys[i].exponent,\n        modulus: publicKeys[i].modulus\n      });\n      return _objectSpread({}, dkim, {}, publicKeys[i], {\n        solidity\n      });\n    }));\n  });\n};\n\nmodule.exports = main;","map":{"version":3,"sources":["/home/devlabs-php/Desktop/projects/ambire/bs/solidity-dkim/parse-email/browser.js"],"names":["Hashes","require","parse","toSolidity","publicKeyToComponents","main","email","resolve","reject","dkims","map","dkim","algorithm","split","pop","toUpperCase","bodyHashMatched","hex","processedBody","signature","hash","toString","processedHeader","publicKeys","fetch","method","mode","cache","headers","referrer","body","domain","selector","then","res","json","entries","entry","publicKey","exponent","modulus","catch","i","solidity","module","exports"],"mappings":"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","sourcesContent":["/*\n  parse and return email data\n  (browser)\n*/\nconst Hashes = require(\"jshashes\");\nconst parse = require(\"./parse\");\nconst toSolidity = require(\"./utils/toSolidity\");\nconst publicKeyToComponents = require(\"./utils/publicKeyToComponents\");\n\nconst main = email => {\n  return new Promise(async (resolve, reject) => {\n    // get dkims\n    const dkims = parse(email).dkims.map(dkim => {\n      const algorithm = dkim.algorithm\n        .split(\"-\")\n        .pop()\n        .toUpperCase();\n\n      const bodyHashMatched =\n        new Hashes[algorithm]().hex(dkim.processedBody) ===\n        dkim.signature.hash.toString(\"hex\");\n\n      if (!bodyHashMatched) {\n        return reject(\"body hash did not verify\");\n      }\n\n      const hash = new Hashes[algorithm]().hex(dkim.processedHeader);\n\n      return {\n        ...dkim,\n        hash\n      };\n    });\n\n    // get dns records\n    const publicKeys = await fetch(\"/api/getPublicKeys\", {\n      method: \"POST\",\n      mode: \"same-origin\",\n      cache: \"no-cache\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      referrer: \"no-referrer\",\n      body: JSON.stringify(\n        dkims.map(dkim => ({\n          domain: dkim.signature.domain,\n          selector: dkim.signature.selector\n        }))\n      )\n    })\n      .then(res => res.json())\n      .then(entries => {\n        return entries.map(entry => {\n          const { publicKey } = entry;\n          const { exponent, modulus } = publicKeyToComponents(publicKey);\n\n          return {\n            ...entry,\n            exponent,\n            modulus\n          };\n        });\n      })\n      .catch(reject);\n\n    return resolve(\n      dkims.map((dkim, i) => {\n        const solidity = toSolidity({\n          algorithm: dkim.algorithm,\n          hash: dkim.hash,\n          signature: dkim.signature.signature,\n          exponent: publicKeys[i].exponent,\n          modulus: publicKeys[i].modulus\n        });\n\n        return {\n          ...dkim,\n          ...publicKeys[i],\n          solidity\n        };\n      })\n    );\n  });\n};\n\nmodule.exports = main;\n"]},"metadata":{},"sourceType":"script"}