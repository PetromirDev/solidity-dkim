{"ast":null,"code":"var _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _defineProperty = require(\"@babel/runtime-corejs2/helpers/defineProperty\");\n\nvar _toArray = require(\"@babel/runtime-corejs2/helpers/toArray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/*\n  parse email\n  (cross-platform)\n*/\nvar Signature = require(\"dkim-signature\");\n\nvar processHeader = require(\"dkim/lib/process-header\");\n\nvar processBody = require(\"dkim/lib/process-body\");\n\nvar isDKIM = require(\"./utils/isDKIM\");\n\nvar emailToHeaderAndBody = function emailToHeaderAndBody(email) {\n  var boundary = email.indexOf(\"\\r\\n\\r\\n\");\n\n  if (boundary === -1) {\n    throw Error(\"no header boundary found\");\n  }\n\n  var header = email.slice(0, boundary);\n  var body = email.slice(boundary + 4);\n  return {\n    boundary: boundary,\n    header: header,\n    body: body\n  };\n};\n\nvar getDkimEntry = function getDkimEntry(dkim) {\n  var _dkim$split = dkim.split(\":\"),\n      _dkim$split2 = _toArray(_dkim$split),\n      name = _dkim$split2[0],\n      rest = _dkim$split2.slice(1);\n\n  return {\n    name: name,\n    value: rest.join(\":\").slice(1)\n  };\n};\n\nvar getDkims = function getDkims(header) {\n  return header.split(/\\r\\n(?=[^\\x20\\x09]|$)/g).map(function (h, i, allHeaders) {\n    if (isDKIM(h)) {\n      // remove DKIM headers\n      var headers = allHeaders.filter(function (v) {\n        return !isDKIM(v);\n      }); // add one DKIM header\n\n      headers.unshift(h);\n      return {\n        entry: getDkimEntry(h),\n        headers: headers\n      };\n    }\n\n    return undefined;\n  }).filter(function (v) {\n    return !!v;\n  });\n};\n\nvar parse = function parse(email) {\n  var _emailToHeaderAndBody = emailToHeaderAndBody(email),\n      header = _emailToHeaderAndBody.header,\n      body = _emailToHeaderAndBody.body;\n\n  var dkims = getDkims(header).map(function (dkim) {\n    var signature = Signature.parse(dkim.entry.value);\n    var sigBody = signature.length != null ? body.slice(0, signature.length) : body;\n    var processedBody = processBody(sigBody, signature.canonical.split(\"/\").pop());\n    var processedHeader = processHeader(dkim.headers, signature.headers, signature.canonical.split(\"/\").shift());\n    var algorithm = signature.algorithm.toUpperCase();\n    return _objectSpread({}, dkim, {\n      signature: signature,\n      processedBody: processedBody,\n      processedHeader: processedHeader,\n      algorithm: algorithm\n    });\n  });\n  return {\n    header: header,\n    body: body,\n    dkims: dkims\n  };\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["/home/devlabs-php/Desktop/projects/ambire/bs/solidity-dkim/parse-email/parse.js"],"names":["Signature","require","processHeader","processBody","isDKIM","emailToHeaderAndBody","email","boundary","indexOf","Error","header","slice","body","getDkimEntry","dkim","split","name","rest","value","join","getDkims","map","h","i","allHeaders","headers","filter","v","unshift","entry","undefined","parse","dkims","signature","sigBody","length","processedBody","canonical","pop","processedHeader","shift","algorithm","toUpperCase","module","exports"],"mappings":"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","sourcesContent":["/*\n  parse email\n  (cross-platform)\n*/\nconst Signature = require(\"dkim-signature\");\nconst processHeader = require(\"dkim/lib/process-header\");\nconst processBody = require(\"dkim/lib/process-body\");\nconst isDKIM = require(\"./utils/isDKIM\");\n\nconst emailToHeaderAndBody = email => {\n  const boundary = email.indexOf(\"\\r\\n\\r\\n\");\n  if (boundary === -1) {\n    throw Error(\"no header boundary found\");\n  }\n\n  const header = email.slice(0, boundary);\n  const body = email.slice(boundary + 4);\n\n  return {\n    boundary,\n    header,\n    body\n  };\n};\n\nconst getDkimEntry = dkim => {\n  const [name, ...rest] = dkim.split(\":\");\n\n  return {\n    name,\n    value: rest.join(\":\").slice(1)\n  };\n};\n\nconst getDkims = header => {\n  return header\n    .split(/\\r\\n(?=[^\\x20\\x09]|$)/g)\n    .map((h, i, allHeaders) => {\n      if (isDKIM(h)) {\n        // remove DKIM headers\n        const headers = allHeaders.filter(v => !isDKIM(v));\n        // add one DKIM header\n        headers.unshift(h);\n\n        return {\n          entry: getDkimEntry(h),\n          headers\n        };\n      }\n\n      return undefined;\n    })\n    .filter(v => !!v);\n};\n\nconst parse = email => {\n  const { header, body } = emailToHeaderAndBody(email);\n\n  const dkims = getDkims(header).map(dkim => {\n    const signature = Signature.parse(dkim.entry.value);\n\n    const sigBody =\n      signature.length != null ? body.slice(0, signature.length) : body;\n\n    const processedBody = processBody(\n      sigBody,\n      signature.canonical.split(\"/\").pop()\n    );\n\n    const processedHeader = processHeader(\n      dkim.headers,\n      signature.headers,\n      signature.canonical.split(\"/\").shift()\n    );\n\n    const algorithm = signature.algorithm.toUpperCase();\n\n    return {\n      ...dkim,\n      signature,\n      processedBody,\n      processedHeader,\n      algorithm\n    };\n  });\n\n  return {\n    header,\n    body,\n    dkims\n  };\n};\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}